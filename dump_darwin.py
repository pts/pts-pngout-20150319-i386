#! /usr/bin/python
# by pts@fazekas.hu at Thu May  4 20:52:34 CEST 2023

import binascii
import subprocess
import sys
import struct

class Part(object):
  __slots__ = ('name', 'ptype', 'addr', 'off', 'size')

  def __init__(self, name, ptype, addr, off, size):
    self.name, self.ptype, self.addr, self.off, self.size = (
        name, ptype, addr, off, size)
    

def main(argv):
  parts = (
      Part('P.ELF_phdr',          '??',          0x8048000, 0x00000, 0x000034),
      Part('P.ELF_ehdr',          '??',          0x8048034, 0x00034, 0x000100),
      Part('P.interp',            'PROGBITS',  0x8048134, 0x00134, 0x000013 + 1),
      Part('P.note.ABI_tag',      'NOTE',        0x8048148, 0x00148, 0x000020),
      Part('P.note.gnu.build_id', 'NOTE',        0x8048168, 0x00168, 0x000024),
      Part('P.hash',              'HASH',        0x804818c, 0x0018c, 0x000164),
      Part('P.gnu.hash',          'GNU_HASH',    0x80482f0, 0x002f0, 0x000030),
      Part('P.dynsym',            'DYNSYM',      0x8048320, 0x00320, 0x000320),
      Part('P.dynstr',            'STRTAB',      0x8048640, 0x00640, 0x0001a1 + 1),
      Part('P.gnu.version',       'VERSYM',      0x80487e2, 0x007e2, 0x000064 + 2),
      Part('P.gnu.version_r',     'VERNEED',     0x8048848, 0x00848, 0x000050),
      Part('P.rel.dyn',           'REL',         0x8048898, 0x00898, 0x000020),
      Part('P.rel.plt',           'REL',         0x80488b8, 0x008b8, 0x000160),
      Part('P.init',              'CODEBITS',    0x8048a18, 0x00a18, 0x000026 + 2),
      Part('P.plt',               'CODEBITS',    0x8048a40, 0x00a40, 0x0002d0),
      Part('P.text',              'CODEBITS',    0x8048d10, 0x00d10, 0x011a00),
      Part('P.fini',              'CODEBITS',    0x805a710, 0x12710, 0x000017 + 0x19),
      Part('P.rodata',            'PROGBITS',    0x805a740, 0x12740, 0x0012e0),
      Part('P.eh_frame_hdr',      'PROGBITS',    0x805ba20, 0x13a20, 0x00020c),
      Part('P.eh_frame',          'PROGBITS',    0x805bc2c, 0x13c2c, 0x000d04 + 0x6d0),
      Part('P.init_array',        'INIT_ARRAY',  0x805d000, 0x15000, 0x000004),
      Part('P.fini_array',        'FINI_ARRAY',  0x805d004, 0x15004, 0x000004),
      Part('P.jcr',               'PROGBITS',  0x805d008, 0x15008, 0x000004),
      Part('P.dynamic',           'DYNAMIC',     0x805d00c, 0x1500c, 0x0000f8),
      Part('P.got',               'PROGBITS',    0x805d104, 0x15104, 0x000004),
      Part('P.got.plt',           'PROGBITS',    0x805d108, 0x15108, 0x0000bc),
      Part('P.data',              'PROGBITS',    0x805d1c4, 0x151c4, 0x00002c),
      Part('P.bss',               'NOBITS',      0x805d200, 0x151f0, 0x000038),
  )
  labels = (
      ('_main', 0x80499c0),

      ('_log', 0x8048a50),
      ('_read', 0x8048a60),
      ('_printf', 0x8048a70),
      ('_fflush', 0x8048a80),
      ('_memmove', 0x8048a90),
      ('_free', 0x8048aa0),
      ('_memcpy', 0x8048ab0),
      ('_fgets', 0x8048ac0),
      ('_fclose', 0x8048ad0),
      ('_time', 0x8048ae0),
      ('_gettimeofday', 0x8048af0),
      ('_stpcpy', 0x8048b00),
      ('_fseek', 0x8048b10),
      ('_fwrite', 0x8048b20),
      ('_strcat', 0x8048b30),
      ('_fread', 0x8048b40),
      ('_strcpy', 0x8048b50),
      ('_realloc', 0x8048b60),
      ('_malloc', 0x8048b70),
      ('_puts', 0x8048b80),
      ('_exit', 0x8048bb0),
      ('_srand', 0x8048bc0),
      ('_strchr', 0x8048bd0),
      ('_strlen', 0x8048be0),
      ('_strcasecmp', 0x8048c00),
      ('_ftell', 0x8048c10),
      ('_fopen', 0x8048c20),
      ('_memset', 0x8048c30),
      ('_fileno', 0x8048c40),
      ('_strtod', 0x8048c50),
      ('_fgetc', 0x8048c60),
      ('_strncasecmp', 0x8048c70),
      ('_rand', 0x8048c80),
      ('_strtok', 0x8048c90),
      ('_vfprintf', 0x8048cb0),
      ('_strtol', 0x8048ce0),

      ('___stdinp', 0x805d204),  # Contains a pointer to the `stdin' value, thus has type FILE**.
      ('___stdoutp', 0x805d220),
      ('___stderrp', 0x805d200),
  )
  
  labels_dict = dict(labels)
  pending_labels = set(labels_dict)
  if len(labels) != len(labels_dict):
    raise ValueError('Duplicate label name.')
  labels_dict_rev = {}
  for name, addr in labels:
    if addr not in labels_dict_rev:
      labels_dict_rev[addr] = []
    labels_dict_rev[addr].append(name)
  end_ofs = 0x151f0
  code_end_addr = 0x805a710 + 0x17
  f = open('pngoutss.golden', 'rb')
  fo = open('pngoutss.s', 'wb')

  addr = 0x8048000
  fo.write('; Generated by %s\n'  % argv[0])
  fo.write('; Compile: nasm -O0 -w+orphan-labels -f bin -o pngoutss pngoutss.nasm\n')
  fo.write('bits 32\ncpu 386\norg 0\nR.code equ $-0x%x\n' % addr)
  ofs = 0
  for part in parts:
    if ofs != part.off:
      raise ValueError('ofs mismatch: ofs=0x%x part.off=0x%x' % (ofs, part.off))
    if addr > part.addr:
      raise ValueError('addr too large: addr=0x%x part.addr=0x%x' % (addr, part.addr))
    fo.write('\n%s:  ; addr=0x%x off=0x%x\n' % (part.name, part.addr, part.off))
    if part.name != 'P.bss':
      f.seek(ofs)
      end_ofs = part.off + part.size
      addr = part.addr
      end_addr = part.addr + part.size
      if part.ptype == 'CODEBITS':  # Disassemble with ndisasm(1).
        data = f.read(part.size)
        if len(data) != part.size:
          raise ValueError('Input file too short.')
        p = subprocess.Popen(('ndisasm', '-b', '32', '-o', '0x%x' % addr, '-'), stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        try:
          data, _ = p.communicate(data)
        finally:
          exit_code = p.wait()
        if exit_code:
          raise RuntimeError('ndisasm failed.')
        for line in data.split('\n'):
          if not line:
            continue
          if line.startswith('         -'):  # Hex continuation of the previous instruction.
            line_hex = line[line.find('-') + 1:]
            data = binascii.unhexlify(line_hex)
            for b in data:
              fo.write('\t.byte 0x%02x\n' % ord(b))
          else:
            if addr in labels_dict_rev:
              for name in labels_dict_rev[addr]:
                fo.write('%s:\n' % name)
                pending_labels.remove(name)
            line_addr, line_hex, line_instr = line.split(None, 2)
            # print [line_addr, line_hex, line_instr]
            line_addr = int(line_addr, 16)
            if line_addr != addr:
              raise ValueError('ndisasm addr mismatch: addr=0x%x line_addr=0x%x' % (addr, line_addr))
            data = binascii.unhexlify(line_hex)
            #if len(data) == 1:  # Single-byte i386 instructions have an unambiguous decoding.
            #  fo.write('..@0x%x: %s\n' % (addr, line_instr))
            #elif data.startswith('\xff\x35') and len(data) == 6:
            #  fo.write('..@0x%x: push dword [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            #elif data.startswith('\x68') and len(data) == 5:
            #  fo.write('..@0x%x: push 0x%x\n' % (addr, struct.unpack('<L', data[1:])[0]))
            #elif data.startswith('\xff\x25') and len(data) == 6:
            #  fo.write('..@0x%x: jmp [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            special = ''
            if data.startswith('\xe8') and len(data) == 5:  # call 0x....
              target_addr = int(line_instr.split(None, 1)[1], 16)
              if target_addr in labels_dict_rev:
                special = '\tcalll %s  # @0x%x\n' % (labels_dict_rev[target_addr][0], addr)
            elif data.startswith('\xa1') and len(data) == 5:  # mov eax,[0x...]
              target_addr = int(line_instr.split(',', 1)[1].strip('[]'), 16)
              if target_addr in labels_dict_rev:
                special = '\tmovl %s, %%eax  # @0x%x\n' % (labels_dict_rev[target_addr][0], addr)
            #elif data.startswith('\xe9') and len(data) == 5:  # jmp 0x....
            #  target_addr = int(line_instr.split(None, 1)[1], 16)
            #  fo.write('..@0x%x: jmp strict near R.code+0x%x\n' % (addr, target_addr))
            if special:
              fo.write(special)
            else:
              fo.write('\t## %s  # @0x%x\n' % (line_instr, addr))
              for b in data:
                fo.write('\t.byte 0x%02x\n' % ord(b))
          addr += len(data)
          ofs += len(data)
        # addr, ofs = end_addr, end_ofs
      else:
        while addr != end_addr:
          line_size = min(16 - (addr & 15), end_addr - addr)
          assert line_size
          data = f.read(line_size)
          if len(data) != line_size:
            raise ValueError('Input file too short.')
          fo.write('\t## nocode  # @0x%x\n' % (addr,))
          for b in data:
            fo.write('\t.byte 0x%02x\n' % ord(b))
          addr += line_size
          ofs += line_size
    else:
      fo.write('absolute $\n')
      addr = part.addr
      fo.write('..@0x%x: resb 0x%x\n' % (addr, part.size))
  if ofs != end_ofs:
    raise ValueError('end_ofs mismatch: ofs=0x%x end_ofs=0x%x' % (ofs, end_ofs))
  #if pending_labels:
  #  raise ValueError('Pending (not-yet-defined) labels: %s' % ', '.join(sorted(pending_labels)))
  fo.write('\n; __END__\n')


if __name__ == '__main__':
  sys.exit(main(sys.argv))
