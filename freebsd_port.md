# Porting software in binary form to FreeBSD

by pts@fazekas.hu at Wed Jun 14 00:40:38 CEST 2023

This document describes the journey of a programmer with Linux experience in
proting software in binary form for Linux i386 to FreeBSD i386. In the
beginning I knew a lot about Linux, but very little about FreeBSD, and I
discovered everything on the fly.

* The host computer is running the Linux amd64 release of Ubuntu 18.04.
* FreeBSD will run in QEMU system emulation (`qemu-system-i386`) on the Linux
  host.
* Software analysis, software development and cross-compiling will
  happen on the Linux host, and the program will be tried on FreeBSD within
  QEMU.
* I did some googling on FreeBSD. Was looking for an old but not too old
  release for i386 I can run in QEMU. `*.qcow2` image files are best: QEMU
  can use them as a system disk image directly. And I don't have to install
  FreeBSD, it's preinstalled to the .qcow2 file.
* I already had the program to be ported as NASM assembly source file. Most
  of it was disassembly (generated by `ndisasm -b 32`) containing fixed
  offsets for code and local variables, without function or variable names.
  So I didn't understand most of it, but I was able to make small changes
  (e.g. change all `call`s from libc function X to Y), compile it with
  `nasm` and try if it still works.
* I managed to get rid of Linux libc functions calls, gradually replacing
  them with Linux i386 syscalls (`int 0x80`), and then I removed the
  reference to `/lib/ld-linux.so.2` (etc.), so the program became statically
  linked. (This part of the work was interesting, but it's Linux specific,
  so I'm not including it in this document.)
* I've chosen FreeBSD 9.3R, which was released on 2014-06-16.
* More info about FreeBSD 9.3R: https://www.freebsd.org/releases/9.3R/readme/
* I figured out the download link of the .qcow2 file.

```
$ wget -O FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2.xz http://ftp-archive.freebsd.org/pub/FreeBSD-Archive/old-releases/VM-IMAGES/9.3-RELEASE/i386/Latest/FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2.xz
... 129 341 372 bytes
$ xzcat <FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2.xz >FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2
... 572 522 496 bytes
$ qemu-img convert -f qcow2 -O raw FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2 image.bin
... image.bin: 21 474 836 480 bytes (sparse file)
$ fdisk -l image.bin 
Disk image.bin: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 79FA443F-08B5-11E4-A99D-D8D385E6D416

Device       Start      End  Sectors  Size Type
image.bin1      34     1057     1024  512K FreeBSD boot
image.bin2    1058  2098209  2097152    1G FreeBSD swap
image.bin3 2098210 41943006 39844797   19G FreeBSD UFS
$ mkdir -p p
```

* Linux can mount a FreeBSD UFS filesystem, I just have to figure out the
  right mount(8) arguments. The FreeBSD 9.3R filesystem seems to need `mount
  -t ufs -o ufstype=ufs2`. There is no autodetection for the `ufstype=`.

```
$ sudo mount -t ufs -o loop,ro,ufstype=ufs2,offset=$((2098210*512)) image.bin p
$ cp -a p/bin/echo ./
$ cp -a p/bin/sync ./
$ file sync
sync: ELF 32-bit LSB executable, Intel 80386, version 1 (FreeBSD), dynamically linked, interpreter /libexec/ld-elf.so.1, for FreeBSD 9.3, stripped
$ readelf -a sync
...
$ file echo
echo: ELF 32-bit LSB executable, Intel 80386, version 1 (FreeBSD), dynamically linked, interpreter /libexec/ld-elf.so.1, for FreeBSD 9.3, stripped
$ readelf -a echo
...
$ readelf -a echo | grep NEEDED
 0x00000001 (NEEDED)                     Shared library: [libc.so.7]
$ find p -name libc.so.7 2>/dev/null | xargs -d '\n' -- ls -ld --sort=none
-r--r--r-- 1 root root 1256844 Jul 11  2014 p/lib/libc.so.7
$ cp -a p/lib/libc.so.7 p/libexec/ld-elf.so.1 ./
$ (cd p && sudo tar cJvf ../FreeBSD-9.3-RELEASE-i386-20140711-r268512.tar.xz * .[^.]*)
$ sudo chown "$(id -nu):$(id -ng)" FreeBSD-9.3-RELEASE-i386-20140711-r268512.tar.xz
$ du -b FreeBSD-9.3-RELEASE-i386-20140711-r268512.tar.xz
126155624       FreeBSD-9.3-RELEASE-i386-20140711-r268512.tar.xz
```

* I have the .tar.xz file now, so I don't need the uncompressed filesystem
  image anymore.

```
$ sudo umount p
$ rmdir p
$ rm -f image.bin
```

* FreeBSD source repository: https://www.freebsd.org/developers/cvs/
* FreeBSD 9.3R sources: https://cgit.freebsd.org/src/tree/?h=releng/9.3
* FreeBSD 9.3R Git clone link: https://git.FreeBSD.org/src.git
* 9.3R /bin/sync C source: https://cgit.freebsd.org/src/tree/bin/sync/sync.c?h=releng/9.3
* 9.3R /bin/echo C source: https://cgit.freebsd.org/src/tree/bin/echo/echo.c?h=releng/9.3

```
$ git clone --branch releng/9.3 --single-branch --depth 1 https://git.FreeBSD.org/src.git
Cloning into 'src'...
remote: Enumerating objects: 58893, done.
remote: Counting objects: 100% (58893/58893), done.
remote: Compressing objects: 100% (52532/52532), done.
remote: Total 58893 (delta 11922), reused 19999 (delta 3580), pack-reused 0
Receiving objects: 100% (58893/58893), 173.36 MiB | 2.56 MiB/s, done.
Resolving deltas: 100% (11922/11922), done.
Checking out files: 100% (54292/54292), done.
$ du -sh src
1020M   src
```

* I Googled for FreeBSD assembly programming.
* brandelf(1) is part of: sudo apt-get install freebsd-buildutils
* Some i386 hello-world source code in GNU as(1), NASM and FASM syntax:
  https://forums.freebsd.org/threads/difference-between-as-and-ld-on-bsd-vs-linux-assembly.75906/
  I saved the source files, including compile instructions.
  hello.fasm
  hello64.s
  hello32.s
  hello32n.nasm
* tutorial for FreeBSD i386 assembly programming:
  https://docs.freebsd.org/en/books/developers-handbook/x86/
* I saved the tutorial to a local .html file.
* The tutorial explains how argc, argv and envp are passed to the program
  (`_start` function) by the FreeBSD kernel. This is exactly the same as in
  Linux:
  ```
  ...  ; Both Linux and FreeBSD i386. The kernel does when executing a program.
  push 0  ; NULL.
  push envp_last  ; (char*) pointer to the last environment variable (NUL-terminated `NAME=VALUE`).
  ...
  push envp_0
  push 0  ; NULL.
  push argv_last  ; (char*) pointer to the last command-line argument (NUL-terminated).
  ...
  push argv_1
  push argv_0  ; (char*) argv[0] pointer, containing the program name.
  push argc  ; Number of elements in argv, excluding the terminating NULL.
  jmp _start  ; _start is a function within the program. Elf32_Ehdr e_entry points to it.
  ```
* The tutorial mentions the syscalls.master file for FreeBSD syscalls.

```
$ du -b src/sys/kern/syscalls.master
43990   src/sys/kern/syscalls.master
```

* It looks like that some smaller Linux and FreeBSD syscall numbers match.
  Let's try to detect the current system (Linux vs FreeBSD) by calling dup(1)
  (__NR_dup == 41 for both systems) using both ABIs, and checking which one
  suceeds.
* Let's use NASM (on Linux) and
  https://raw.githubusercontent.com/pts/minilibc686/master/elf0.inc.nasm
  to create an ELF executable. Source is in poly.nasm.

```
$ nasm-0.98.39 -O0 -w+orphan-labels -f bin -o poly poly.nasm
$ chmod +x poly
$ ./poly; echo $?
Hello, Linux!
0
$ mkisofs -R -J -o poly.iso poly
$ qemu-system-i386 -net none -m 256M -machine pc-1.0 -hda FreeBSD-9.3-RELEASE-i386-20140711-r268512.qcow2 -cdrom poly.iso
(Keep it running.)
```

In the new, black QEMU window, at the boot prompt, I chose 2 (Single user), then pressed <Enter> for the `/bin/sh` prompt, then

```
(At FreeBSD root prompt.)
# mount_cd9660 /dev/cd0 /tmp
# /tmp/poly
ELF binary type "0" not known.
/tmp/poly: Exec format error
# halt
(Takes about 30 seconds, with the last line:)
Please press any key to reboot.
```

* Then I closed the QEMU window by pressing Ctrl-<C> in the termnal window
  running *qemu-system-i386*.
* I changed EI_OSABI from 0 (SYSV) to 9 (FreeBSD), recompiled, reran on
  Linux (it still worked), and reran in QEMU (it worked).

```
(At FreeBSD root prompt.)
# mount_cd9660 /dev/cd0 /tmp
# /tmp/poly; echo $?
Hello, FreeBSD!
0
```

* The program to be ported was already statically linked, so I didn't have
  to worry about library dependencies.
* Fortunately the program didn't use *errno*, so I didn't have to populate
  it after each syscall.
* I figured out which Linux syscalls the program to be ported needs by
  looking at its disassembly.

```
$ ndisasm-0.98.39 -b 32 -e 0x74 -o 0x8048074 prog
```

* On both Linux and FreeBSD, the syscalls are called with `int 0x80`, so I
  searched for that.
* syscall calling convention on Linux: Linux expects the syscall number in
  EAX, syscall arguments in registers EBX, ECX, EDI, ESI, EDI, EBP, and
  returns value or -errno in EAX.
* syscall calling convention on FreeBSD: FreeBSD expects the syscall number
  in EAX, syscall arguments pushed to the stack in reverse order, a dummy
  value pushed to the stack, returns value in EAX and CF=0 on success, and
  indicates failure with CF=1 and positive errno in EAX.
* Syscall arguments etc. are documented in the FreeBSD `syscalls.master`
  file, see above. That file also indicates STD (part of all FreeBSD
  systems) or COMPAT (enabled by #ifdef at kernel compilation time).
* I've found these syscalls: sys_exit, sys_mmap2, mremap, munmap, read,
  write, open, close, lseek, time, ioctl, gettimeofday.

read(...), write(...), close(...), sys_exit(...):

* `sys_exit(int exit_code);`: 1 for Linux and FreeBSD.
* read(...): 3 for Linux and FreeBSD.
* write(...): 4 for Linux and FreeBSD.
* close(...): 6 for Linux and FreeBSD.
* These seem to work exactly the same way, except for the calling convention.

ioctl(...) and isatty(...):

* ioctl(...) was used only for isatty(3).
  ```
  int isatty(int fd) {  /* Linux. */
    struct termios term;
    return ioctl(fd, TCGETS, &term) == 0;
  }
  ```
* By looking at Linux diet libc header files, I replaced the Linux version
  with:
  ```
  #define TCGETS 0x5401
  struct termios { char data[0x24]; };
  int isatty(int fd) {  /* Linux. */
    struct termios term;
    return ioctl(fd, TCGETS, &term) == 0;  /* Syscall 54 on Linux i486. */
  }
  ```
* I looked for the FreeBSD equivalent:
  ```
  $ find src -iname '*isatty.c'
  src/lib/libc/gen/isatty.c
  $ find src -iname '*tcgetattr.c'
  $ rgrep tcgetattr src/lib/libc
  ...
  src/lib/libc/gen/termios.c:tcgetattr(int fd, struct termios *t)
  ...
  $ find src -iname 'termios.h'
  src/sys/sys/termios.h
  src/include/termios.h
  $ find src -iname '*_termios.h'
  src/sys/sys/_termios.h
  src/sys/compat/svr4/svr4_termios.h
  src/sys/i386/ibcs2/ibcs2_termios.h
  $ rgrep 'struct termios {' src
  src/sys/sys/_termios.h:struct termios {
  $ rgrep '#define.*TIOCGETA' src
  src/sys/sys/ttycom.h:#define    TIOCGETA        _IOR('t', 19, struct termios) /* get termios struct */
  $ rgrep '#define[^!-~]*_IOR' src
  ...
  src/sys/sys/ioccom.h:#define    _IOR(g,n,t)     _IOC(IOC_OUT,   (g), (n), sizeof(t))
  ...
  $ rgrep '#define[^!-~]*_IOC' src
  src/sys/sys/ioccom.h:#define    _IOC(inout,group,num,len)       ((unsigned long) \
  ...
  $ (cat src/sys/sys/_termios.h src/sys/sys/ioccom.h; echo "int f(void) { return _IOR('t', 19, struct termios); }") >t.c && gcc -m32 -fno-pic -S t.c && grep eax t.s
          movl    $1076655123, %eax
  ```
* Its relevant part was:
  ```
  int isatty(int fd) {  /* FreeBSD. */
    struct termios t;
    return tcgetattr(fd, &t) != -1;
  }
  ```
* After some looking around in FreeBSD `src/lib/libc`, I replaced it with:
  ```
  #define TIOCGETA 0x402c7413  /* 1076655123 */
  struct termios { char data[0x2c]; };
  int isatty(int fd) {  /* FreeBSD. */
    struct termios t;
    return _ioctl(fd, TIOCGETA, &t) != -1;
  }
  ```

lseek(...):

* Then I looked for lseek(...):
  ```
  $ rgrep 'typedef.*off_t;' src
  ..
  src/sys/sys/_types.h:typedef    __int64_t       __off_t;        /* file offset */
  src/sys/sys/types.h:typedef     __off_t         off_t;          /* file offset */
  ...
  $ rgrep 'typedef.*caddr_t;' src
  src/sys/sys/types.h:typedef     char *          caddr_t;        /* core address */
  ...
  $ find src -iname '*lseek*c'
  src/lib/libc/sys/lseek.c
  src/lib/libstand/lseek.c
  ```
* More info about libstand:
  https://man.freebsd.org/cgi/man.cgi?query=libstand&apropos=0&sektion=0&manpath=FreeBSD+9.3-RELEASE&format=html
* It looks like *libstand* is bootloader stuff, so let's look at `src/lib/libc/sys/lseek.c`.
  ```
  off_t lseek(int fd, off_t offset, int whence) {  /* FreeBSD, off_t is int64_t. */
    return (__getosreldate() >= 700051) ? __sys_lseek(fd, offset, whence) :
        __sys_freebsd6_lseek(fd, 0, offset, whence);
  }
  ```
  Please note that `off_t` is 64 bits on FreeBSD.
* `__getosreldate()` seems to look at ELF auxv (_elf_aux_info(...)), falling back to sysctl(...).
  I will simplify it to:
  ```
  off_t lseek(int fd, off_t offset, int whence) {  /* FreeBSD, off_t is int64_t. */
    off_t result = sys_freebsd6_lseek(fd, 0, offset, whence);  /* FreeBSD syscall 199. */
    if (result != (off_t)-1) return result;
    return sys_olseek(fd, offset, whence);  /* FreeBSD COMPAT syscall 19. */
  }
  ```
* FreeBSD 6.0 (providing sys_freebsd6_lseek(...)) was released on 2005-11-04.
* On Linux, the program used Linux i386 syscall 19 for lseek(...), with int32_t offset.
* The SEEK_SET, SEEK_CUR and SEEK_END constant values for whence are the
  same in Linux and FreeBSD.

gettimeofday(...):

* Both Linux and FreeBSD has `int gettimeofday(struct timeval *tv, struct timezone *tz);`.
* FreeBSD:
  ```
  $ rgrep __sys_gettimeofday src
  src/lib/libc/include/libc_private.h:int __sys_gettimeofday(struct timeval *, struct timezone *);
  $ rgrep 'struct timeval {' src/sys/sys
  src/sys/sys/_timeval.h:struct timeval {
  ```
* Both struct timeval fields (time_t tv_sec; tv_usec) are int32_t on FreeBSD
* i386, just like on Linux.
* However, the syscall number is different: gettimeofday(...)  /* 78 for Linux, 116 for FreeBSD. */

time(...):

* Linux i386 has syscall 13 for time(...), FreeBSD doesn't have any syscall.
* FreeBSD libc:
  ```
  $ rgrep 'time(time_t' src/lib/libc
  src/lib/libc/gen/time.c:time(time_t *t)
  ```
* It's implemented like this:
  ```
  time_t time(time_t *t) {  /* FreeBSD. CLOCK_SECOND is FreeBSD-specific. */
    struct timespec tt;
    const time_t retval = (clock_gettime(CLOCK_SECOND, &tt) < 0) ? -1 : tt.tv_sec;
    if (t != NULL) *t = retval;
    return retval;
  }
  ```
* I'll implement this using gettimeofday(...) instead:
  ```
  time_t time(time_t *t) {  /* FreeBSD. */
    struct timeval tv;
    const time_t retval = (sys_gettimeofday(CLOCK_SECOND, &tt) < 0) ? -1 : tv.tv_sec;
    if (t != NULL) *t = retval;
    return retval;
  }
  ```

open(...):

* `int open(const char *pathname, int flags, mode_t mode);`: 5 for Linux and FreeBSD.
* The program calls open(2) with flags O_RDONLY == 0, and another time with
  O_WRONLY | O_CREAT | O_TRUNC == 1 | 0100 | 01000.
* Let's see the O_... constants on FreeBSD.
  ```
  $ rgrep '#define.*O_TRUNC' src
  ...
  src/sys/sys/fcntl.h:#define     O_TRUNC         0x0400          /* truncate to zero length */
  ...
  $ grep -E 'O_RDONLY|O_WRONLY|O_CREAT|O_TRUNC' src/sys/sys/fcntl.h
  #define O_RDONLY        0x0000          /* open for reading only */
  #define O_WRONLY        0x0001          /* open for writing only */
  #define O_CREAT         0x0200          /* create if nonexistent */
  #define O_TRUNC         0x0400          /* truncate to zero length */
  ...
  ```
* So O_CREAT and O_TRUNC are different. On FreeBSD: O_WRONLY | O_CREAT | O_TRUNC == 1 |
  0x200 | 0x400 == 0x601.

mmap(...), mremap(...) and munmap(...):

* sys_mmap2(...):
  ```
  void *mmap2(void *addr, size_t length, int prot, int flags, int fd, size_t ofs_shr_12);  /* 192 for Linux. */
  int ommap(int ommap(void *addr, int len, int prot, int flags, int fd, long pos); }  /* 71 for FreeBSD COMPAT; prot flags are different. */
  caddr_t freebsd6_mmap(caddr_t addr, size_t len, int prot, int flags, int fd, int pad, off_t pos);  /* 197 for FreeBSD. */
  caddr_t mmap(caddr_t addr, size_t len, int prot, int flags, int fd, off_t pos); }  /* 477 for FreeBSD. */
  ```
* munmap(...): 91 for Linux, 73 for FreeBSD.
* mremap(...): 163 for Linux. Not implemented for FreeBSD. We need a
* fallback: mmap(...) + memcpy(...) + munmap(...).

Plan:

* I write the FreeBSD implementation of syscall wrappers sys_exit, read
  write, open, close, lseek, ioctl, gettimeofday, time in assembly language.
* I make it so that it continues working on both Linux and FreeBSD.
* I write a dummy implementation of syscall wrappers sys_mmap2, mremap,
  munmap, they always return an error.
* I try the program on both Linux and FreeBSD. It should work up to the
  first memory allocation.
  
FreeBSD 3.0 (1998-10-16) compatibility:

* What is the minimum FreeBSD version to run this program? Determine by
  syscall numbers. Some already need FreeBSD 6.0. COMPAT in syscalls.master
  is for compatibility FreeBSD earlier than 4.0. FreeBSD 3.0 was released on
  1998-10-16.
* FreeBSD 3.0 source tree:
  ```
  $ git clone --branch stable/3 --single-branch --depth 1 https://git.FreeBSD.org/src.git src3
  ...
  ```
* Syscalls are documented in `src3/sys/kern/syscalls.master`.
  https://cgit.freebsd.org/src/tree/sys/kern/syscalls.master?h=stable/3
* Syscalls:
  * sys_exit: 1
  * sys_mmap: 71, 197, (no 477)
  * mremap: none
  * munmap: 73
  * read: 3
  * write: 4
  * open: 5
  * close: 6
  * lseek: 19 (32-bit offset), 199 (64-bit offset)
  * time: none
  * ioctl: 54
  * gettimeofday: 116
* It looks like the ported program would work on FreeBSD 3.0 as well.

__END__
