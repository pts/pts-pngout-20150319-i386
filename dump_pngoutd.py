#! /usr/bin/python
# by pts@fazekas.hu at Mon May  8 02:16:57 CEST 2023
#
# This is a Python 2 script, it works e.g. with Python 2.7.
#

import binascii
import subprocess
import sys
import struct

class Part(object):
  __slots__ = ('name', 'ptype', 'addr', 'off', 'size')

  def __init__(self, name, ptype, addr, off, size):
    if off is None:
      off = addr - 0x8048000
    if off < 0:
      raise ValueError('Negative part off in file: name=%s 0x%x' % (name, off))
    self.name, self.ptype, self.addr, self.off, self.size = (
        name, ptype, addr, off, size)


def main(argv):
  parts = (  # Based on the `Load command' output of: i386-apple-darwin14-otool -lv pngoutda
      Part('P.MachO_hdr',         'PROGBITS',    0x8048000,  None,  +0xd10),
      Part('P.text',              'CODEBITS',    0x8048d10,  None,  +0x11988),
      Part('P.gap15',             'PROGBITS',    0x805a698,  None,  +0xd4),
      Part('P.rodata',            'PROGBITS',    0x805a76c,  None,  +0x12b4),
      Part('P.gap16',             'PROGBITS',    0x805ba20,  None,  +0x17a4),
      Part('P.data',              'PROGBITS',    0x805d1c4,  None,  +0x2c),
      Part('P.MachO_trail',       'PROGBITS',    0x805d1f0,  None,  +0x14f8),
      #Part('P.bss',               'NOBITS',      0x805d225,  None,  0x181f81b + 2 * 0x400),
  )
  labels = (
  )

  target_labels_dict = {
  }

  labels_dict = dict(labels)
  pending_labels = set(labels_dict)
  if len(labels) != len(labels_dict):
    raise ValueError('Duplicate label name.')
  labels_dict_rev = {}
  for name, addr in labels:
    if addr not in labels_dict_rev:
      labels_dict_rev[addr] = []
    labels_dict_rev[addr].append(name)
  final_end_ofs = 0x166e8  # 91880 bytes.
  f = open('pngoutda.golden', 'rb')
  fo = open('pngoutd2.nasm', 'wb')

  addr = 0x8048000
  fo.write('; Generated by %s\n'  % argv[0])
  fo.write('; Compile: tools/nasm-0.98.39 -O0 -w+orphan-labels -f bin -o pngoutd pngoutd.nasm\n')
  fo.write('bits 32\ncpu 386\norg 0\nR.code equ $-0x%x\n' % addr)
  ofs = 0
  for part in parts:
    if ofs != part.off:
      raise ValueError('ofs mismatch: name=%s ofs=0x%x part.off=0x%x' % (part.name, ofs, part.off))
    if addr > part.addr:
      raise ValueError('addr too large: part=%s addr=0x%x part.addr=0x%x' % (part.name, addr, part.addr))
    fo.write('\n%s:  ; addr=0x%x off=0x%x\n' % (part.name, part.addr, part.off))
    if part.name != 'P.bss':
      f.seek(ofs)
      end_ofs = part.off + part.size
      addr = part.addr
      end_addr = part.addr + part.size
      if part.ptype == 'CODEBITS':  # Disassemble with ndisasm(1).
        data = f.read(part.size)
        if len(data) != part.size:
          raise ValueError('Input file too short.')
        p = subprocess.Popen(('tools/ndisasm-0.98.39', '-b', '32', '-o', '0x%x' % addr, '-'), stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        try:
          data, _ = p.communicate(data)
        finally:
          exit_code = p.wait()
        if exit_code:
          raise RuntimeError('ndisasm failed.')
        for line in data.split('\n'):
          if not line:
            continue
          if line.startswith('         -'):  # Hex continuation of the previous instruction.
            line_hex = line[line.find('-') + 1:]
            data = binascii.unhexlify(line_hex)
            fo.write('..@0x%x: db %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data)))
          else:
            if addr in labels_dict_rev:
              for name in labels_dict_rev[addr]:
                fo.write(';%s:\n' % name)
                pending_labels.remove(name)
            line_addr, line_hex, line_instr = line.split(None, 2)
            # print [line_addr, line_hex, line_instr]
            line_addr = int(line_addr, 16)
            if line_addr != addr:
              raise ValueError('ndisasm addr mismatch: addr=0x%x line_addr=0x%x' % (addr, line_addr))
            data = binascii.unhexlify(line_hex)
            #if len(data) == 1:  # Single-byte i386 instructions have an unambiguous decoding.
            #  fo.write('..@0x%x: %s\n' % (addr, line_instr))
            #elif data.startswith('\xff\x35') and len(data) == 6:
            #  fo.write('..@0x%x: push dword [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            #elif data.startswith('\x68') and len(data) == 5:
            #  fo.write('..@0x%x: push 0x%x\n' % (addr, struct.unpack('<L', data[1:])[0]))
            #elif data.startswith('\xff\x25') and len(data) == 6:
            #  fo.write('..@0x%x: jmp [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            special = ''
            if data.startswith('\xe8') and len(data) == 5:  # call 0x....
              target_addr = int(line_instr.split(None, 1)[1], 16)
              if target_addr in labels_dict_rev:
                name = labels_dict_rev[target_addr][0]
                if name in target_labels_dict:
                  target_addr = target_labels_dict[name]
                  special = '..@0x%x: call R.code+0x%x  ; Patched %s.\n' % (addr, target_addr, name)
            elif data.startswith('\xa1') and len(data) == 5:  # mov eax, [0x...]
              target_addr = int(line_instr.split(',', 1)[1].strip('[]'), 16)
              if target_addr in labels_dict_rev:
                name = labels_dict_rev[target_addr][0]
                if name in target_labels_dict:
                  target_addr = target_labels_dict[name]
                  special = '..@0x%x: mov eax, [0x%x]  ; Patched %s.\n' % (addr, target_addr, name)
            #elif data.startswith('\xe9') and len(data) == 5:  # jmp 0x....
            #  target_addr = int(line_instr.split(None, 1)[1], 16)
            #  fo.write('..@0x%x: jmp strict near R.code+0x%x\n' % (addr, target_addr))
            if special:
              fo.write(special)
            else:
              fo.write('..@0x%x: db %s  ;; %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data), line_instr))
          addr += len(data)
          ofs += len(data)
        # addr, ofs = end_addr, end_ofs
      else:
        while addr != end_addr:
          line_size = min(16 - (addr & 15), end_addr - addr)
          assert line_size
          data = f.read(line_size)
          if len(data) != line_size:
            raise ValueError('Input file too short: part=%s' % (part.name,))
          fo.write('..@0x%x: db %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data)))
          addr += line_size
          ofs += line_size
    else:
      fo.write('absolute $\n')
      addr = part.addr
      fo.write('..@0x%x: resb 0x%x\n' % (addr, part.size))
  if ofs != final_end_ofs:
    raise ValueError('final_end_ofs mismatch: ofs=0x%x final_end_ofs=0x%x' % (ofs, final_end_ofs))
  #if pending_labels:
  #  raise ValueError('Pending (not-yet-defined) labels: %s' % ', '.join(sorted(pending_labels)))
  fo.write('\n; __END__\n')


if __name__ == '__main__':
  sys.exit(main(sys.argv))
