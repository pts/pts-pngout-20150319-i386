#! /usr/bin/python
# by pts@fazekas.hu at Sat May  6 16:10:18 CEST 2023

import binascii
import subprocess
import sys
import struct

class Part(object):
  __slots__ = ('name', 'ptype', 'addr', 'off', 'size')

  def __init__(self, name, ptype, addr, off, size):
    self.name, self.ptype, self.addr, self.off, self.size = (
        name, ptype, addr, off, size)
    

def main(argv):
  parts = (
      Part('P.ELF_ehdr',  'PROGBITS', 0x8042000, 0x00000,  +0x00034),
      Part('P.ELF_phdr',  'PROGBITS', 0x8042034, 0x00034,  +0x00060),
      Part('P.gap1',      'PROGBITS', 0x8042094, 0x00094,  +0x0042c),
      Part('P.ucrodata',  'PROGBITS', 0x80424c0, 0x004c0,  +0x0161c),
      Part('P.gap2',      'PROGBITS', 0x8043adc, 0x01adc,  +0x00004),
      Part('P.uctext',    'CODEBITS', 0x8043ae0, 0x01ae0,  +0x05229),
      Part('P.gap3',      'CODEBITS', 0x8048d09, 0x06d09,  +0x00007),
      Part('P.text',      'CODEBITS', 0x8048d10, 0x06d10,  +0x11988),
      Part('P.gap5',      'PROGBITS', 0x805a698, 0x18698,  +0x000d4),
      Part('P.rodata',    'PROGBITS', 0x805a76c, 0x1876c,  +0x012b4),
      Part('P.gap6',      'PROGBITS', 0x805ba20, 0x19a20,  +0x00520),
      Part('P.ucdata',    'PROGBITS', 0x805cf40, 0x19f40,  +0x0026c),
      Part('P.gap7',      'PROGBITS', 0x805d1ac, 0x1a1ac,  +0x00018),
      Part('P.data',      'PROGBITS', 0x805d1c4, 0x1a1c4,  +0x0002c),
      Part('P.bss',       'NOBITS',   0x805d200, 0x1a1f0,  +0x181f840 + 0x023e0),
      # Part('P.ucbss', ...) is included in .bss.
  )
  labels = (
      ('main', 0x80499c0),

      ('log', 0x6001),
      ('read', 0x6002),
      ('printf', 0x6003),
      ('fflush', 0x6004),
      ('memmove', 0x6005),
      ('free', 0x6006),
      ('memcpy', 0x6007),
      ('fgets', 0x6008),
      ('fclose', 0x6009),
      ('time', 0x600a),
      ('gettimeofday', 0x600b),
      ('stpcpy', 0x600c),
      ('fseek', 0x600d),
      ('fwrite', 0x600e),
      ('strcat', 0x600f),
      ('fread', 0x6010),
      ('strcpy', 0x6011),
      ('realloc', 0x6012),
      ('malloc', 0x6013),
      ('puts', 0x6014),
      ('exit', 0x6015),
      ('srand', 0x6016),
      ('strchr', 0x6017),
      ('strlen', 0x6018),
      ('strcasecmp', 0x6019),
      ('ftell', 0x601a),
      ('fopen', 0x601b),
      ('memset', 0x601c),
      ('fileno', 0x601d),
      ('strtod', 0x601e),
      ('fgetc', 0x601f),
      ('strncasecmp', 0x6020),
      ('rand', 0x6021),
      ('strtok', 0x6022),
      ('vfprintf', 0x6023),
      ('strtol', 0x6024),

      ('stdin',  0x6100),  # Contains a pointer to the `stdin' value, thus has type FILE**.
      ('stdout', 0x6101),
      ('stderr', 0x6102),
  )

  target_labels_dict = {
      '_init_and_fini': 0x8043ae0,
      '_start': 0x8043ae1,
      'FAKE_main': 0x8043aff,
      'main': 0x80499c0,
      '__uClibc_main': 0x80477b5,

      'exit': 0x8047552,  # Correct.
      'fclose': 0x8043df3,
      'fflush': 0x8045279,
      'fgetc': 0x80452ee,
      'fgets': 0x8045372,
      'fileno': 0x80453d4,
      'fopen': 0x8043f02,
      'fread': 0x8045430,
      'free': 0x8046b2c,
      'fseek': 0x8043f1a,
      'ftell': 0x8043f35,
      'fwrite': 0x8045495,
      'gettimeofday': 0x8043d57,
      'log': 0x8043b30,
      'malloc': 0x8045e1f,
      'memcpy': 0x8045b0c,
      'memmove': 0x8045b33,
      'memset': 0x8045b5a,
      'printf': 0x8043fe5,
      'puts': 0x8043f69,
      'rand': 0x8046dfb,
      'read': 0x8043d89,
      'realloc': 0x80465c1,
      'srand': 0x8046efc,
      'stpcpy': 0x8045cc6,
      'strcasecmp': 0x8045cdc,
      'strcat': 0x8045b6f,
      'strchr': 0x8045b8e,
      'strcpy': 0x8045bac,
      'strlen': 0x8045bc7,
      'strncasecmp': 0x8045d12,
      'strtod': 0x80472b6,
      'strtok': 0x8045d53,
      'strtol': 0x804717b,
      'time': 0x8043dbf,
      'vfprintf': 0x80445df,

      'stdin': 0x805cf40,
      'stdout': 0x805cf44,
      'stderr': 0x805cf48,
  }
  
  labels_dict = dict(labels)
  pending_labels = set(labels_dict)
  if len(labels) != len(labels_dict):
    raise ValueError('Duplicate label name.')
  labels_dict_rev = {}
  for name, addr in labels:
    if addr not in labels_dict_rev:
      labels_dict_rev[addr] = []
    labels_dict_rev[addr].append(name)
  final_end_ofs = 0x1a1f0
  f = open('pngoutx_unpatched', 'rb')
  fo = open('pngoutx2.nasm', 'wb')

  addr = 0x8042000
  fo.write('; Generated by %s\n'  % argv[0])
  fo.write('; Compile: nasm -O0 -w+orphan-labels -f bin -o pngoutss pngoutss.nasm\n')
  fo.write('bits 32\ncpu 386\norg 0\nR.code equ $-0x%x\n' % addr)
  ofs = 0
  for part in parts:
    if ofs != part.off:
      raise ValueError('ofs mismatch: ofs=0x%x part.off=0x%x' % (ofs, part.off))
    if addr > part.addr:
      raise ValueError('addr too large: part=%s addr=0x%x part.addr=0x%x' % (part.name, addr, part.addr))
    fo.write('\n%s:  ; addr=0x%x off=0x%x\n' % (part.name, part.addr, part.off))
    if part.name != 'P.bss':
      f.seek(ofs)
      end_ofs = part.off + part.size
      addr = part.addr
      end_addr = part.addr + part.size
      if part.ptype == 'CODEBITS':  # Disassemble with ndisasm(1).
        data = f.read(part.size)
        if len(data) != part.size:
          raise ValueError('Input file too short.')
        p = subprocess.Popen(('ndisasm', '-b', '32', '-o', '0x%x' % addr, '-'), stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        try:
          data, _ = p.communicate(data)
        finally:
          exit_code = p.wait()
        if exit_code:
          raise RuntimeError('ndisasm failed.')
        for line in data.split('\n'):
          if not line:
            continue
          if line.startswith('         -'):  # Hex continuation of the previous instruction.
            line_hex = line[line.find('-') + 1:]
            data = binascii.unhexlify(line_hex)
            fo.write('..@0x%x: db %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data)))
          else:
            if addr in labels_dict_rev:
              for name in labels_dict_rev[addr]:
                fo.write(';%s:\n' % name)
                pending_labels.remove(name)
            line_addr, line_hex, line_instr = line.split(None, 2)
            # print [line_addr, line_hex, line_instr]
            line_addr = int(line_addr, 16)
            if line_addr != addr:
              raise ValueError('ndisasm addr mismatch: addr=0x%x line_addr=0x%x' % (addr, line_addr))
            data = binascii.unhexlify(line_hex)
            #if len(data) == 1:  # Single-byte i386 instructions have an unambiguous decoding.
            #  fo.write('..@0x%x: %s\n' % (addr, line_instr))
            #elif data.startswith('\xff\x35') and len(data) == 6:
            #  fo.write('..@0x%x: push dword [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            #elif data.startswith('\x68') and len(data) == 5:
            #  fo.write('..@0x%x: push 0x%x\n' % (addr, struct.unpack('<L', data[1:])[0]))
            #elif data.startswith('\xff\x25') and len(data) == 6:
            #  fo.write('..@0x%x: jmp [0x%x]\n' % (addr, struct.unpack('<L', data[2:])[0]))
            special = ''
            if data.startswith('\xe8') and len(data) == 5:  # call 0x....
              target_addr = int(line_instr.split(None, 1)[1], 16)
              if target_addr in labels_dict_rev:
                name = labels_dict_rev[target_addr][0]
                if name in target_labels_dict:
                  target_addr = target_labels_dict[name]
                  special = '..@0x%x: call R.code+0x%x  ; Patched %s.\n' % (addr, target_addr, name)
            elif data.startswith('\xa1') and len(data) == 5:  # mov eax, [0x...]
              target_addr = int(line_instr.split(',', 1)[1].strip('[]'), 16)
              if target_addr in labels_dict_rev:
                name = labels_dict_rev[target_addr][0]
                if name in target_labels_dict:
                  target_addr = target_labels_dict[name]
                  special = '..@0x%x: mov eax, [0x%x]  ; Patched %s.\n' % (addr, target_addr, name)
            #elif data.startswith('\xe9') and len(data) == 5:  # jmp 0x....
            #  target_addr = int(line_instr.split(None, 1)[1], 16)
            #  fo.write('..@0x%x: jmp strict near R.code+0x%x\n' % (addr, target_addr))
            if special:
              fo.write(special)
            else:
              fo.write('..@0x%x: db %s  ;; %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data), line_instr))
          addr += len(data)
          ofs += len(data)
        # addr, ofs = end_addr, end_ofs
      else:
        while addr != end_addr:
          line_size = min(16 - (addr & 15), end_addr - addr)
          assert line_size
          data = f.read(line_size)
          if len(data) != line_size:
            raise ValueError('Input file too short: part=%s' % (part.name,))
          fo.write('..@0x%x: db %s\n' % (addr, ', '.join('0x%02x' % ord(b) for b in data)))
          addr += line_size
          ofs += line_size
    else:
      fo.write('absolute $\n')
      addr = part.addr
      fo.write('..@0x%x: resb 0x%x\n' % (addr, part.size))
  if ofs != final_end_ofs:
    raise ValueError('final_end_ofs mismatch: ofs=0x%x final_end_ofs=0x%x' % (ofs, final_end_ofs))
  #if pending_labels:
  #  raise ValueError('Pending (not-yet-defined) labels: %s' % ', '.join(sorted(pending_labels)))
  fo.write('\n; __END__\n')


if __name__ == '__main__':
  sys.exit(main(sys.argv))
